## Chapter 3 - 코드에서 나는 악취

- "웃긴 농담은 필자가 쓴 것이고 나머지는 켄트가 쓴 것이다."
- 리팩토링해야하는 코드들. 냄새가 난다는 표현
- 이상한 이름
  - 이해하기 힘든 변수, 필드, 함수명 등
- 중복 코드
- 긴 함수
  - 짧은 쪽이 이해하기 쉽다.
  - 함수 이름은 동작 방식이 아닌 '의도intention' 가 드러나게 짓는다.
  - 전체 코드가 길어지더라도 새로운 함수로 분리하는게 좋다.
- 긴 매개변수 목록
- 전역 데이터
  - 전역 변수, 클래스 변수, 싱글톤 등
- 가변 데이터
  - 데이터의 불변성 가급적 유지하는게 좋다
- 뒤엉킨 변경
  - 단일 책임 원칙이 지켜지지 않을 때 생기는 현상
  - 코드 수정할 때 하나의 부분에서만 수정하는게 아니라 여러 군데의 수정이 필요할 경우
  - 하나의 함수 등이 여러가지 책임을 가지고 있는 경우. → 맥락별 '분리'가 필요
- 산탄총 수술
  - 뒤엉킨 변경과 비슷하지만 반대 개념.
  - 여러 코드에 한가지 기능이 분산된 상태. → 맥락별 '모음' 이 필요
- 기능 편애
  - 어떤 함수가 자기가 속한 모듈의 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 많을 때
- 데이터 뭉치
  - 자주 같이 쓰이는 데이터들 → 예를 들면 하나의 클래스 객체로 묶어서 사용
- 기본형 집착
  - 전화번호, 화폐, 좌표 등등을 기본형으로 계산하려고 하는 경우
  - 해당 자료에 맞는 객체로 추출하여 사용
- 반복되는 스위치문
  - 지금은 스위치문 자체가 문제로 인식되진 않지만 중복되는 부분은 걸러내는 편이 좋음
- 반복문
- 성의없는 요소
  - 그 요소의 구조가 필요없거나, 실질적 메서드가 하나뿐인 클래스 등 역할이 적은 코드
  - 제거하는게 좋음
- 추측성 일반화
  - '나중에 필요할 거야' 라는 생각으로 넣어둔 hooking 포인트, 특이 케이스 처리 로직 등.
- 임시 필드
  - 특정 상황에서만 값이 설정되는 필드 등..
- 메시지 체인
  - 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드
    - 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미
- 중개자
  - 외부로부터 세부 사항을 숨겨주는 캡슐화encapsulation. 캡슐화하는 과정에서 위임delegation 이 자주 활용된다. 이 위임 과정이 과하다면 수정이 필요
- 내부자 거래
  - 모듈(객체?)
  - 사이의 데이터 거래가 많아지면 사적으로 처리하는 부분을 줄여야 함.
- 거대한 클래스
  - 한 클래스가 너무 큰 경우. 필드가 많거나 코드 량이 많거나.
- 서로 다른 인터페이스의 대안 클래스들
  - 클래스를 사용할 때 장점은 필요에 따라 다른 클래스로 교체할 수 있다는 점.
  - 이를 위해서는 인터페이스가 같아야 한다. → 이를 위해 리팩토링
- 데이터 클래스
  - 데이터 클래스란 - 데이터 필드와 게터/세터 메서드로 구성된 클래스
  - 이런 클래스에 public 필드가 있다면 캡슐화 등으로 숨기고 접근을 막는다.
  - 또 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의되어 있을 수 있따
    - 이런 경우 클라이언트 코드를 데이터 클래스로 옮기기만 해도 개선
- 상속 포기
  - 부모의 유산이 필요 없는 경우 → 서브클래스가 부모의 동작은 필요하지만 인터페이스는 따르고 싶지 않을 경우
    - 리팩토링해서 아예 상속 매커니즘에서 벗어나보기
- 주석
  - 주석으로 설명을 구구절절 할 수록 문제가 있는 코드일 확률 높음.
  - "주석이 필요없는 코드로 리팩토링해보자."
